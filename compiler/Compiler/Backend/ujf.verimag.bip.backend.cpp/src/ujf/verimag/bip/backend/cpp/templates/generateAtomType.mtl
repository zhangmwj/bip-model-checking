[comment encoding = UTF-8 /]
[module generateAtomType('http://bip2/1.0')/]

[import ujf::verimag::bip::backend::cpp::templates::commonBip /]
[import ujf::verimag::bip::backend::cpp::templates::naming /]
[import ujf::verimag::bip::backend::cpp::templates::behaviorAnalyzer /]
[import ujf::verimag::bip::backend::cpp::templates::port::generateAtomExportPort /]
[import ujf::verimag::bip::backend::cpp::templates::port::generateAtomInternalPort /]
[import ujf::verimag::bip::backend::cpp::templates::port::generateAtomExternalPort /]
[import ujf::verimag::bip::backend::cpp::templates::port::generatePortValue /]
[import ujf::verimag::bip::backend::cpp::templates::generateExportData /]
[import ujf::verimag::bip::backend::cpp::templates::traceBip /]
[import ujf::verimag::bip::backend::cpp::templates::atom::expressions /]
[import ujf::verimag::bip::backend::cpp::templates::gcc /]
[import ujf::verimag::bip::backend::acceleo::templates::annotations /]


[comment
    Returns the variable name (scope: the class corresponding to the Atom Type being handled)
    for the port declaration given as parameter.
    In most cases, this name is the same as the one of the declaration. Exception
    when the implicit internal port syntax is used (export port PT_t p()). In this
    case, a prefix is added to the variable.
/]

[query private guard(transition : Transition) : ValuedExpression =
	transition.guard
/]

[query public varName(anInternalDecl : AtomInternalExternalPortDeclaration) : String =
    '_iport_decl__' + anInternalDecl.name
/]

[query private varName(anExportDecl : AtomExportPortDeclaration) : String =
    '_eport_decl__' + anExportDecl.name
/]

[query private currentTime(anAtomType : AtomType) : String = 'mTime' /]

[query private atomInvariant(anAtomType : AtomType) : String = 'mInvariant' /]

[query private atomInvariantConstraint(anAtomType : AtomType) : String = 'mInvariantConstraint' /]

[query private atomResume(anAtomType : AtomType) : String = 'mResume' /]

[comment 
    Returns the variable name corresponding to the PortValue associated with
    the given internal port declaration.
/]
[query public getPVVarName(anAtomInternalDecl : AtomInternalPortDeclaration) : String = '_iport_decl_pv__' + anAtomInternalDecl.name /]

[query public getIsEnabledVarName(anAtomInternalDecl : AtomInternalPortDeclaration) : String = '_iport_decl_isEnabled__' + anAtomInternalDecl.name /]

[comment 
    Returns the variable name corresponding to the TimingConstraint associated with
    the given internal port declaration.
/]
[query public getGuardVarName(p : AtomInternalExternalPortDeclaration) : String = '_iport_decl_guard__' + p.name /]
[query public getGuardAfterPrioVarName(p : AtomInternalExternalPortDeclaration) : String = '_iport_decl_guard_after_prio__' + p.name /]
[query public getGuardConstraintVarName(p : AtomInternalExternalPortDeclaration) : String = '_iport_decl_guard_constraint__' + p.name /]

[query public hasTimingConstraint(anAtom : AtomType) : Boolean = 
	anAtom.internalPortDeclarations->exists(p : AtomInternalPortDeclaration | hasTimingConstraint(p)) or
	anAtom.externalPortDeclarations->exists(p : AtomExternalPortDeclaration | hasTimingConstraint(p)) or
	anAtom.invariants->exists(i : AtomInvariant | hasTimingConstraint(i)) or
	anAtom.behavior.initialResume->notEmpty()
/]

[query public hasTimingConstraint(anAtomInternal : AtomInternalPortDeclaration) : Boolean =
	let anAtom : AtomType = anAtomInternal.eContainer(AtomType) in
		anAtom.behavior.transitions
			->select(tr:Transition | tr.hasTimingConstraint())
			->select(tr:Transition | tr.triggerPort->notEmpty())
			->select(tr:Transition | tr.triggerPort = anAtomInternal)
			->notEmpty()
/]

[query public hasTimingConstraint(anAtomExternal : AtomExternalPortDeclaration) : Boolean =
	let anAtom : AtomType = anAtomExternal.eContainer(AtomType) in
		anAtom.behavior.transitions
			->select(tr:Transition | tr.hasTimingConstraint())
			->select(tr:Transition | tr.triggerPort->notEmpty())
			->select(tr:Transition | tr.triggerPort = anAtomExternal)
			->notEmpty()
/]

[query public hasTimingConstraint(aTransition : Transition) : Boolean =
	if aTransition.guard->notEmpty() then
		aTransition.guard.getMayReadClocks()->notEmpty() or
		aTransition.guard.getMayWriteClocks()->notEmpty()
	else
		false
	endif or
	not (aTransition.urgency = Urgency::lazy) or
	aTransition.resume->notEmpty()
/]


[query public hasTimingConstraint(anInvariant : AtomInvariant) : Boolean = 
	if anInvariant.guard->notEmpty() then
		anInvariant.guard.getMayReadClocks()->notEmpty() or
		anInvariant.guard.getMayWriteClocks()->notEmpty()
	else
		false
	endif
/]

[query public hasTimingConstraint(aPrio : AtomPriorityDeclaration) : Boolean = 
	if aPrio.guard->notEmpty() then
		aPrio.guard.getMayReadClocks()->notEmpty() or
		aPrio.guard.getMayWriteClocks()->notEmpty()
	else
		false
	endif
/]

[query public allClockDeclarations(anAtom : AtomType) : Set(ClockDeclaration) =
	if (isOptimEnabled('inactive-clocks')) then
		anAtom.activeClocks()
	else
		anAtom.clockDeclarations
	endif
/]

[query public hasClockDeclaration(anAtom : AtomType, S : String) : Boolean = 
	anAtom.allClockDeclarations()->exists(cl : ClockDeclaration | cl.name = S)
 /]



[query public getIsPreviouslyEnabledVarName(anAtomInternalDecl : AtomInternalPortDeclaration) : String = '_iport_decl_isPreviouslyEnabled__' + anAtomInternalDecl.name /]

[query public getIsEnabledByTransitionsVarName(anAtomInternalDecl : AtomInternalPortDeclaration) : String = '_iport_decl_isEnabledByTransitions__' + anAtomInternalDecl.name /]

[query public pguardVarName(anAtomPrioDecl : AtomPriorityDeclaration) : String = '_prioguard__' + anAtomPrioDecl.name /]

[query public penabledVarName(anAtomPrioDecl : AtomPriorityDeclaration) : String = '_prioenabled__' + anAtomPrioDecl.name /]

[query public enabledVarName(path : Sequence(AtomPriorityDeclaration)) : String =
	let atom : AtomType = path->first().eContainer(AtomType) in
		'_priopathenabled' +
		path->iterate(p : AtomPriorityDeclaration ; ret : String = '' | ret + '__' + atom.priorities->indexOf(p))
/]

[comment 
    Returns a varname that uniquely identify a transition within
    the atom.
 /]
[query public index(aTransition : Transition) : Integer = 
    let pn : PetriNet = aTransition.eContainer(PetriNet) in
        pn.transitions->indexOf(aTransition)
/]

[query public uniqueVarName(aTransition : Transition) : String = 
    let pn : PetriNet = aTransition.eContainer(PetriNet) in
        '_transguard__' + index(aTransition)
/]

[query public uniqueConstraintVarName(aTransition : Transition) : String = 
    let pn : PetriNet = aTransition.eContainer(PetriNet) in
        '_transguardConstraint__' + index(aTransition)
/]

[comment
    Returns true if the atom has custom data type for at least one of its data
/]
[query private usesCustomDataTypes(anAtomType : AtomType) : Boolean = 
    anAtomType.allDataDeclarations()->select(s:DataDeclaration| not s.dataType.native)->notEmpty()
/]

[query public internalPorts(atom : AtomType) : OrderedSet(AtomInternalPortDeclaration) =
	atom.internalPortDeclarations
/]

[query public externalPorts(atom : AtomType) : OrderedSet(AtomExternalPortDeclaration) =
	atom.externalPortDeclarations
/]

[query public transitions(atom : AtomType) : OrderedSet(Transition) =
	atom.behavior.transitions
/]

[query public internalTransitions(atom : AtomType) : OrderedSet(Transition) =
	atom.behavior.transitions->select(t : Transition | t.triggerPort->isEmpty())
/]

[query public portTransitions(atom : AtomType) : OrderedSet(Transition) =
	atom.behavior.transitions->select(t : Transition | t.triggerPort->notEmpty())
/]

[query public internalPortTransitions(atom : AtomType) : OrderedSet(Transition) =
	atom.behavior.transitions
		->select(t : Transition | t.triggerPort->notEmpty())
		->select(t : Transition | t.triggerPort.oclIsKindOf(AtomInternalPortDeclaration))
/]

[query public externalPortTransitions(atom : AtomType) : OrderedSet(Transition) =
	atom.behavior.transitions
		->select(t : Transition | t.triggerPort->notEmpty())
		->select(t : Transition | t.triggerPort.oclIsKindOf(AtomExternalPortDeclaration))
/]

[query public transitions(port : AtomInternalExternalPortDeclaration) : OrderedSet(Transition) =
	port.eContainer(AtomType).behavior.transitions
		->select(t : Transition | t.triggerPort = port)
/]

[query public transitions(port : AtomExportPortDeclaration) : Set(Transition) =
	port.portDeclarationReferences
		->iterate(p : AtomInternalPortDeclaration ;
			ret : Set(Transition) = Set { } |
				ret->union(transitions(p)))
/]

[query public isExported(aData : DataDeclaration) : Boolean =
	if (aData.oclIsKindOf(AtomInternalDataDeclaration)) then
		aData.oclAsType(AtomInternalDataDeclaration).exported
	else
		false
	endif
/]

[query public exportedData(anAtomType : AtomType) : OrderedSet(AtomInternalDataDeclaration) =
	anAtomType.internalDataDeclarations
		->select(dd : AtomInternalDataDeclaration | dd.exported)
/]

[query public exportedDataTypes(anAtomType : AtomType) : Set(DataType) =
	anAtomType.exportedData()->collect(dataType)->asSet()
/]

[query public allDataDeclarations(anAtomType : AtomType) : Sequence(DataDeclaration) =
	anAtomType.dataParameterDeclarations
		->asSequence()
		->union(anAtomType.internalDataDeclarations->asSequence())
/]

[template public generateHeaderBody(anAtomType : AtomType, disableSerialization : Boolean)
    {
        cl : String = anAtomType.className();
        internalExportedData : Collection(AtomInternalDataDeclaration) = anAtomType.internalDataDeclarations->select(d:AtomInternalDataDeclaration| d.exported);
        internalBasicData : Collection(DataDeclaration) = anAtomType.allDataDeclarations()->select(ddd:DataDeclaration| ddd.dataType.native);
        internalNotBasicData : Collection(DataDeclaration) = anAtomType.allDataDeclarations()->select(ddd:DataDeclaration|not ddd.dataType.native);
    }]
#include <Atom.hpp>
#include <TimeValue.hpp>
#include <Interval.hpp>
#include <Clock.hpp>
#include <Constraint.hpp>

[for (userInclude : String | anAtomType.getUserIncludes()) before('// User include given in @cpp annotation\n')]
#include <[userInclude/]>
[/for]

[for (classNameWithPath : String | anAtomType.aIPTypesWithRelPath())]
#include <[classNameWithPath/]>
[/for]

[for (classNameWithPath : String | anAtomType.aExternalPTypesWithRelPath())]
#include <[classNameWithPath/]>
[/for]

[for (classNameWithPath : String | anAtomType.aEPTypesWithRelPath())]
#include <[classNameWithPath/]>
[/for]

[for (classNameWithPath : String | anAtomType.pVTypesWithRelPath())]
#include <[classNameWithPath/]>
[/for]

[for (aDataType : DataType | anAtomType.exportedDataTypes())]
#include <[relHppFilePath(anAtomType, aDataType.exportDataClassName(anAtomType))/]>
[/for]

[if (isMarshEnabled())]
// for memcpy
#include <string.h>
// for marshalling, need BipError
#include <CycleInAtomPrioritiesError.hpp>
#include <NonDeterministicPetriNetError.hpp>
#include <NonOneSafePetriNetError.hpp>
#include <ClockWithNegativeValueError.hpp>
[/if]

class [cl /] : public Atom {
private:
[for (decl : AtomInternalPortDeclaration | internalPorts(anAtomType)) before ('   // internal ports & associated port values\n')]
   	// Lotfi : Port has annotation ? [decl.hasAnnotation('stochastic', 'dist')/]
	[if decl.hasAnnotation('stochastic', 'dist')]//   Value ? [decl.getAnnotation('stochastic', 'dist') /] [/if]
	[if decl.hasAnnotation('stochastic', 'dist')]//   Is const ? [decl.isConstAnnotation('stochastic', 'dist') /] [/if]   
    [decl.portType.atomInternalClassName()/] &[decl.varName() /];
    [decl.portType.portValueClassName()/] [decl.getPVVarName() /];


[if (anAtomType.hasTimingConstraint())]
    Interval [decl.getGuardVarName() /];
    Interval [decl.getGuardAfterPrioVarName() /];
    Constraint [decl.getGuardConstraintVarName() /];
[/if]
[/for]
[for (decl : AtomExternalPortDeclaration | externalPorts(anAtomType)) before ('   // external ports\n')]
    [decl.atomExternalClassName()/] &[decl.varName() /];
[if (anAtomType.hasTimingConstraint())]
    Interval [decl.getGuardVarName() /];
    Interval [decl.getGuardAfterPrioVarName() /];
[/if]
[/for]
[for (decl : AtomExportPortDeclaration | anAtomType.exportPortDeclarations) before('\n    // exported ports\n')]
    [decl.portType.atomExportClassName()/] &[decl.varName()/];
[/for][for (decl : DataDeclaration | anAtomType.exportedDataDeclarations) before('\n    // exported data\n')]
    [decl.dataType.exportDataClassName(anAtomType)/] &[decl.exportedVarName()/];
[/for]
public:
	
	//return here Lotfi
	void print_data_vars(string s){
		[for (dd : DataDeclaration | anAtomType.allDataDeclarations()) before('\n    // component data declarations\n')]

			[if(dd.dataType.typeName().toString() = 'bool')]
						if([dd.varName()/] == 1)
							cout <<  "var" << " [dd.dataType.typeName()/] " <<  s << ".[dd.name/] " << "true" << endl;
						else
							cout <<  "var" << " [dd.dataType.typeName()/] " <<  s << ".[dd.name/] " << "false" << endl;
			[else]
						cout <<  "var" << " [dd.dataType.typeName()/] " <<  s << ".[dd.name/] " << [dd.varName()/] << endl;
			[/if]
   		[/for]
	}


    [anAtomType.genCtorProto()/];
    virtual ~[cl /]();
    virtual vector<Constraint> allTimingConstraints() const;
    virtual BipError& execute(PortValue &portValue, const TimeValue &t);
    virtual BipError& execute(PortValue &portValue);
    virtual BipError& execute(AtomExternalPort &portValue, const TimeValue &t);
    virtual BipError& initialize();
[if (not disableSerialization)]
    virtual string toString() const;
[/if]
    const Interval &invariant() const { return [atomInvariant(anAtomType)/]; }
    const Constraint &invariantConstraint() const { return [atomInvariantConstraint(anAtomType)/]; }
[if (anAtomType.invariants->exists(i : AtomInvariant | hasTimingConstraint(i)))]
    bool hasInvariant() const { return true; }
[else]
    bool hasInvariant() const { return false; }
[/if]
    BipError &resume(const TimeValue &time);
    const Interval &resume() const { return [atomResume(anAtomType)/]; }

[for (ddecl : AtomInternalDataDeclaration | internalExportedData)
      before('    // getters for exported data\n')]
    const [ddecl.dataType.typeName()/] & get_[ddecl.name/]() const;
[/for]

[for (ddecl : DataDeclaration | anAtomType.allDataDeclarations())
      before('\n    // getters for component data declarations\n')]
    [ddecl.dataType.typeName()/] get_[ddecl.name/]() const;
[/for]

[if (isMarshEnabled())]
    size_t bytesSize() const;
    char* toBytes(char*buf, size_t *len) const;
    bool fromBytes(const char *buf, size_t len);
    bool disposeBytes(const char *buf) const;
[/if]
[for (aState : State | anAtomType.behavior.states)]
    bool at[aState.name/]() const;
[/for]

protected:
    void setTime(const TimeValue &time);
    TimeValue [currentTime(anAtomType)/];
    Interval [atomResume(anAtomType)/];
    Interval [atomInvariant(anAtomType)/];
    Constraint [atomInvariantConstraint(anAtomType)/];

    BipError& update();
[if (isOptimEnabled('transitions-update'))]
    BipError& update_all();
    BipError& update_initial();
[for (t : Transition | anAtomType.behavior.transitions)]
    BipError& update_[index(t)/]();
[/for]
[/if]

    BipError& executeInternalTransitions();
    BipError& checkInvariants();

    const static size_t bvector_size = [anAtomType.numStates()/]/(8*sizeof(int))+(([anAtomType.numStates()/]%(8*sizeof(int))) > 0 ? 1 : 0);
    int __statesbv['['/] bvector_size [']'/];
    [for (dd : DataDeclaration | anAtomType.allDataDeclarations()) before('\n    // component data declarations\n')]
    [if (dd.const)]const [/if][dd.dataType.typeName()/] [dd.varName()/];
    [/for]

    [for (cd : ClockDeclaration | allClockDeclarations(anAtomType)) before('\n    // clocks\n')]
    Clock [cd.varName()/];
    [/for]

    [for (t : Transition | anAtomType.behavior.transitions) before('\n    // enabledness of transitions\n')]
    [if (not hasTimingConstraint(t))]
    bool [t.uniqueVarName()/];
    [else]
    Interval [t.uniqueVarName()/];
    Constraint [t.uniqueConstraintVarName()/];
    [/if]
    [/for]

[if (anAtomType.hasTimingConstraint())]
    Interval generateInterval(const double &speed, const TimeValue &r, bool open) const;

[/if]
    [for (p : AtomPriorityDeclaration | anAtomType.priorities) before('\n    // guards of priorities\n')]
    bool [p.pguardVarName()/];
    [/for]
    [for (p : AtomPriorityDeclaration | anAtomType.priorities) before('\n    // enabledness of priorities\n')]
    bool [p.penabledVarName()/];
    [/for]
    [for (p : AtomPriorityDeclaration | anAtomType.priorities) before('\n    // enabledness of priority paths\n') separator('\n')]
    [for (path : Sequence(AtomPriorityDeclaration) | upperPaths(p))]
    bool [enabledVarName(path)/];
    [/for]
    [/for]

    // index of the latest executed transition
    int __previous;

[for (aState : State | anAtomType.behavior.states)]
    bool to[aState.name/]();
    bool from[aState.name/]();
[/for]
};
[for (ddecl : AtomInternalDataDeclaration | internalExportedData)
    before('\n// getters\n') separator('\n')]
inline
const [ddecl.dataType.typeName()/] & [cl/]::get_[ddecl.name/]() const {
    return [ddecl.varName()/];
}
[/for]
[for (ddecl : DataDeclaration | anAtomType.allDataDeclarations())
      before('\n    // getters for component data declarations\n')]
inline
[ddecl.dataType.typeName()/] [cl/]::get_[ddecl.name/]() const {
    return [ddecl.varName()/];
}
[/for]

[if (isMarshEnabled())]

inline size_t [cl/]::bytesSize() const {
    size_t size = ([anAtomType.sizeOfBasicData()/]) + // basic data
                  ([anAtomType.sizeOfInternals()/]) + // internals
                  ([anAtomType.sizeOfNotBasicData()/]); // non basic
    [comment][for (dd : AtomInternalDataDeclaration | internalNotBasicData)]
    [dd.dataType.typeName()/]_sizeof([dd.varName()/]);
    [/for][/comment]
    return size;
}

inline char * [cl/]::toBytes(char *buf, size_t *len) const{
    char *c; 
    *len = bytesSize();
    if (buf == NULL) {
        c = new char['['/] *len [']'/];
    } else {
        c = buf;
    }

    size_t idx = 0;
    // store pnet state
    memcpy(c+idx, __statesbv, bvector_size*sizeof(int));
    idx += bvector_size*sizeof(int);

    [for (dd : DataDeclaration | internalBasicData) before('    // copy basic data\n')]
    [if (dd.dataType.name = 'string')]
    memcpy(c+idx, [dd.varName()/].c_str(), [dd.varName()/].size() + 1);
    idx += [dd.varName()/].size() + 1;
    [else]
    memcpy(c+idx, &[dd.varName()/], sizeof([dd.dataType.typeName()/]));
    idx += sizeof([dd.dataType.typeName()/]);
    [/if]
    [/for]

    [for (dd : DataDeclaration | internalNotBasicData) before('    // copy non basic data\n')]
    //memcpy(c+idx, &[dd.varName()/], sizeof([dd.dataType.typeName()/]));
    [dd.dataType.functionNameForMarshallingNBD()/](c+idx, &[dd.varName()/]);
    idx += [dd.dataType.functionNameForSizeOfNBD()/]([dd.varName()/]);
    [/for]
    assert(*len == idx);
    return c;
}

inline bool [cl/]::fromBytes(const char *buf, size_t len) {
    const char *c = buf;
    size_t idx = 0;
    // restore pnet state
    memcpy(__statesbv, c, bvector_size*sizeof(int));
    c+= bvector_size*sizeof(int);
    idx += bvector_size*sizeof(int);
    [for (dd : DataDeclaration | internalBasicData) before('    // basic data\n')]
    [if (dd.dataType.name = 'string')]
    [dd.varName()/] = std::string(c);
    c += [dd.varName()/].size()+1;
    idx += [dd.varName()/].size()+1;
    [else]
    memcpy(&[dd.varName()/], c, sizeof([dd.dataType.typeName()/]));
    idx += sizeof([dd.dataType.typeName()/]);
    c += sizeof([dd.dataType.typeName()/]);
    [/if]
    [/for]

    [for (dd : DataDeclaration | internalNotBasicData) before('    // non basic data\n')]
    // memcpy(&[dd.varName()/], c, sizeof([dd.dataType.typeName()/]));
    [dd.dataType.functionNameForUnmarshallingNBD()/](&[dd.varName()/], c);
    idx += [dd.dataType.functionNameForSizeOfNBD()/]([dd.varName()/]);
    c += [dd.dataType.functionNameForSizeOfNBD()/]([dd.varName()/]);
    [/for]
    assert(len == idx);

    // disable check of previous transition
    __previous = -1;

	BipError *ret = &checkInvariants();
	if (ret->type() != NO_ERROR) return false;

    // execute internal transitions
    ret = &executeInternalTransitions();

    if (ret->type() != NO_ERROR) return false;
	return (update().type() != NO_ERROR);
}

inline bool [cl/]::disposeBytes(const char *buf) const {
    delete['[]'/] buf;
    return true;
}
[/if]
[if (anAtomType.hasTimingConstraint())]
inline void [cl/]::setTime(const TimeValue &t) {
    // logical time should not decrease
    assert(this->[currentTime(anAtomType)/] <= t);

    // logical should meet current invariant
[if (anAtomType.invariants->exists(i : AtomInvariant | hasTimingConstraint(i)))]
    assert([atomInvariant(anAtomType)/].in(t));
[/if]

    // set new logical time
    this->[currentTime(anAtomType)/] = t;
}

inline Interval [cl/]::generateInterval(const double &speed, const TimeValue &r, bool open) const {
    if (speed == 0.0) {
        return Interval(r == TimeValue::ZERO);
    }
    else if (speed > 0.0) {
        return Interval(r/speed + this->[currentTime(anAtomType)/], TimeValue::MAX, open, false);
    }
    else {
        return Interval(TimeValue::MIN, r/speed + this->[currentTime(anAtomType)/], false, open);
    }
}
[/if]
[/template]


[comment
    if prio has the form XXXX < p1, then simply check if the port p1 has a port value
    if prio has the form WWWW < *, then check if any other port (ie. <> WWWW) has a port value
/]
[template public isUpStateRuleEnabled(aPrioDecl : AtomPriorityDeclaration) post(trim())]
[if (aPrioDecl.high->notEmpty())]
this->[aPrioDecl.high.varName()/].isEnabled()
[else]
([for (aPortDecl : AtomInternalPortDeclaration | aPrioDecl.eContainer(AtomType).internalPortDeclarations->select(p:AtomInternalPortDeclaration| p<> aPrioDecl.low))
      separator(' || ')]
this->[aPortDecl.varName()/].isEnabled()[/for])
[/if]
[/template]

[template private genCondition(path : Sequence(AtomPriorityDeclaration)) post(trim())]
([for (prio : AtomPriorityDeclaration | path) separator(' && ')]
[prio.pguardVarName()/][/for] && [path->last().isUpStateRuleEnabled()/])
[/template]

[template private genComment(path : Sequence(AtomPriorityDeclaration)) post(trim())]
[for (p : AtomPriorityDeclaration | path) separator(', ')][p.name/][/for]
[/template]

[template private genComment(port : AtomInternalPortDeclaration, path : Sequence(AtomPriorityDeclaration)) post(trim())]
[port.name/][for (p : AtomPriorityDeclaration | path) before(' < ') separator(' < ')]
[if (p.high->notEmpty())][p.high.name/][else]*[/if][/for]
[/template]

[template private generatePriorityCondition(port : AtomInternalPortDeclaration,
	paths : Set(Sequence(AtomPriorityDeclaration)),
	tab : String)
	post(trim()) {
	orderedPaths : Sequence(Sequence(AtomPriorityDeclaration)) = paths->asSequence();
}]
[for (path : Sequence(AtomPriorityDeclaration) | orderedPaths)]
[tab/][enabledVarName(path)/][if (orderedPaths->indexOf(path) < paths->size())] ||[/if] // [genComment(port, path)/]
[/for]
[/template]

[template private genApplyPriorityCode(left : AtomInternalPortDeclaration, right : AtomInternalPortDeclaration) post(trim()) {
	atom : AtomType = left.eContainer(AtomType);
}]
if ([left.varName()/].hasPortValue() && [right.varName()/].hasPortValue()) {
	[if (atom.hasTimingConstraint())]
    if (![left.getGuardAfterPrioVarName()/].empty() && ![right.getGuardVarName()/].empty()) {
        Interval waitInterval = [left.getGuardAfterPrioVarName()/].wait(this->[currentTime(atom)/], [left.getPVVarName()/].urgency());

        if (hasInvariant()) {
            waitInterval &= invariant();
        }

        if (!([right.getGuardVarName()/] && waitInterval).empty()) {
            Interval complementRight = Interval([right.getGuardVarName()/].right(), TimeValue::MAX, ![right.getGuardVarName()/].rightOpen(), false);

            [left.getGuardAfterPrioVarName()/] &= complementRight;
        }
        else {
            Interval complementLeft = Interval(TimeValue::MIN, [right.getGuardVarName()/].left(), false, ![right.getGuardVarName()/].leftOpen());
            Interval complementRight = Interval([right.getGuardVarName()/].right(), TimeValue::MAX, ![right.getGuardVarName()/].rightOpen(), false);

            if (complementLeft.in(this->[currentTime(atom)/])) {
                 [left.getGuardAfterPrioVarName()/] &= complementLeft;
            }
            else {
                 [left.getGuardAfterPrioVarName()/] &= complementRight;
            }
        }
    }
    [else]
    [left.varName()/].setIsEnabled(false);
    [left.varName()/].clearPortValue();
    [/if]
}
[/template]

[template private genInheritUrgencyCode(left : AtomInternalPortDeclaration, right : AtomInternalPortDeclaration) post(trim()) {
	atom : AtomType = left.eContainer(AtomType);
}]
if ([left.varName()/].hasPortValue() && [right.varName()/].hasPortValue()) {
	[if (atom.hasTimingConstraint())]
    if (![left.getGuardVarName()/].empty() && ![right.getGuardVarName()/].empty()) {
        Interval waitInterval = [left.getGuardVarName()/].wait(this->[currentTime(atom)/], [left.getPVVarName()/].urgency());
        assert(!waitInterval.empty());
        TimeValue potentialTimeLock = waitInterval.right();

        if ([right.getGuardAfterPrioVarName()/].wait(this->[currentTime(atom)/], [right.getPVVarName()/].urgency()).right() > potentialTimeLock) {
            if ([right.getGuardAfterPrioVarName()/].in(potentialTimeLock)) {
                [right.getGuardAfterPrioVarName()/] &= Interval(TimeValue::MIN, potentialTimeLock);

                if ([right.getPVVarName()/].urgency() == LAZY) {
                    [right.getPVVarName()/].setUrgency(DELAYABLE);
                }
            }
        }
    }
    [/if]
}
[/template]

[template private generateUpdateGuardsOfPriorities(priorities : Set(AtomPriorityDeclaration)) post(trim())]
[for (prio : AtomPriorityDeclaration | priorities) before('\n// update guards of priorities\n')]
[if (prio.guard->notEmpty())][prio.guard.gtc()/][/if]
[prio.pguardVarName()/] = [if (prio.guard->notEmpty())][prio.guard.generateExpression()/][else]true[/if];
[/for]
[/template]

[template private generateCheckForCyclesInPriorities(atom : AtomType, priorities : Set(AtomPriorityDeclaration)) post(trim())]
[for (cycle : Set(AtomPriorityDeclaration) |
		cycles(atom)->select(c : Set(AtomPriorityDeclaration) |
			c->intersection(priorities)->notEmpty()))
      before ('// check for cycles in priorities\nif (') 
      separator(' || \n    ') 
      after(')\n    return *(new CycleInAtomPrioritiesError());\n')]
[for (prio : AtomPriorityDeclaration | cycle) before('(') separator(' && ') after(')') ]
[prio.pguardVarName()/][/for]
[/for]
[/template]

[template private generatePriorities(atom : AtomType,
	transitions : Set(Transition),
	priorities : Set(AtomPriorityDeclaration),
	errorVarName : String)
	post(trim()) {
	ports : Set(AtomInternalPortDeclaration) =
		atom.internalPortDeclarations
			->select(p : AtomInternalPortDeclaration |
				p.disabledByPrioritiesDependsOn(transitions, priorities));
}]
[generateUpdateGuardsOfPriorities(priorities)/]

[generateCheckForCyclesInPriorities(atom, priorities)/]
[if (hasTimingConstraint(atom))]
[for (port : AtomInternalPortDeclaration | ports) before('\n// compute urgency inheritence\n') separator('\n')]
[generateUrgencyInheritence(port)/]
[/for]

[for (port : AtomInternalPortDeclaration | ports) before('\n// applies priorities (domination)\n') separator('\n')]
[generateApplyPriorities(port)/]
[/for]
[else]
[for (port : AtomInternalPortDeclaration | ports) before('\n') separator('\n')]
[generatePriorities(port, transitions, priorities)/]
[/for]
[/if]
[/template]

[template private generateUrgencyInheritence(port : AtomInternalPortDeclaration) post(trim()) {
	atom : AtomType = port.eContainer(AtomType);
	paths : Set(Sequence(AtomPriorityDeclaration)) = lowerPaths(port);
}]
[for (path : Sequence(AtomPriorityDeclaration) | paths)]
[let lowerPriority : AtomPriorityDeclaration = path->last()]
[let lowerPorts : OrderedSet(AtomInternalPortDeclaration) =
		internalPorts(atom)
			->select(p : AtomInternalPortDeclaration |
				appliesLow(lowerPriority, p))]
if ([for (prio : AtomPriorityDeclaration | path) separator(' && ')][prio.pguardVarName()/][/for]) {
[for (p : AtomInternalPortDeclaration | lowerPorts)]
    [genInheritUrgencyCode(p, port)/]
[/for]
}
[/let]
[/let]
[/for]
[/template]

[template private generateApplyPriorities(port : AtomInternalPortDeclaration) post(trim()) {
	atom : AtomType = port.eContainer(AtomType);
	paths : Set(Sequence(AtomPriorityDeclaration)) = lowerPaths(port);
}]
[for (path : Sequence(AtomPriorityDeclaration) | paths)]
[let higherPriority : AtomPriorityDeclaration = path->last()]
[let higherPorts : OrderedSet(AtomInternalPortDeclaration) =
		internalPorts(atom)
			->select(p : AtomInternalPortDeclaration |
				appliesHigh(higherPriority, p))]
if ([for (prio : AtomPriorityDeclaration | path) separator(' && ')][prio.pguardVarName()/][/for]) {
[for (p : AtomInternalPortDeclaration | higherPorts)]
    [genApplyPriorityCode(port, p)/]
[/for]
}
[/let]
[/let]
[/for]
[/template]

[template private generatePriorities(port : AtomInternalPortDeclaration,
	transitions : Set(Transition),
	priorities : Set(AtomPriorityDeclaration)) post(trim()) {
	modifiedPaths : Set(Sequence(AtomPriorityDeclaration)) =
		upperPaths(port)
			->select(path : Sequence(AtomPriorityDeclaration) |
				activeDependsOn(path, transitions, priorities));
	stablePaths : Set(Sequence(AtomPriorityDeclaration)) =
		upperPaths(port) - modifiedPaths;
}]
// recompute modified priority paths
[for (path : Sequence(AtomPriorityDeclaration) | modifiedPaths)]
[enabledVarName(path)/] = [genCondition(path)/]; // [genComment(path)/]
[/for]

// applies priorities to port [port.name/]
[if (modifiedPaths->notEmpty())]if ([port.generatePriorityCondition(modifiedPaths, '    ')/]
    ) {
    // disable port [port.name/]
    [port.varName()/].setIsDisabledByPriorities(true);
}
else [if (stablePaths->notEmpty())]if ([port.generatePriorityCondition(stablePaths, '    ')/]
    ) {
    // disable port [port.name/]
    [port.varName()/].setIsDisabledByPriorities(true);
}
else [/if]{
    [port.varName()/].setIsDisabledByPriorities(false);
}
[/if]
[/template]

[template private genEnabled(aPrio : AtomPriorityDeclaration) ? (appliesHigh(aPrio)->isEmpty())]
[aPrio.pguardVarName()/]
[/template]

[template private genEnabled(aPrio : AtomPriorityDeclaration) ? (appliesHigh(aPrio)->notEmpty())]
[aPrio.pguardVarName()/] && ([for (p : AtomInternalPortDeclaration | appliesHigh(aPrio)) separator(' || ')][p.varName()/].isEnabled()[/for])
[/template]

[template private sizeOfInternals(anAtomType : AtomType) post(trim())]
(bvector_size*sizeof(int))
[/template]

[template private sizeOfBasicData(anAtomType : AtomType) post(trim())
{
        cl : String = anAtomType.className();
        internalBasicData : Collection(DataDeclaration) = anAtomType.allDataDeclarations()->select(ddd:DataDeclaration| ddd.dataType.native);
    }
]
0 [for (dd : DataDeclaration | internalBasicData) before('+ ') separator('+')][if (dd.dataType.name = 'string')][dd.varName()/].size()+1[else]sizeof([dd.dataType.typeName()/])[/if][/for]
[/template]

[template private functionNameForSizeOfNBD(aNonBasicDataType : DataType) post(trim())]
[aNonBasicDataType.name/]_sizeof
[/template]

[template private functionNameForMarshallingNBD(aNonBasicDataType : DataType) post(trim())]
[aNonBasicDataType.name/]_marshalling
[/template]

[template private functionNameForUnmarshallingNBD(aNonBasicDataType : DataType) post(trim())]
[aNonBasicDataType.name/]_unmarshalling
[/template]

[template private sizeOfNotBasicData(anAtomType : AtomType) post(trim())
{
        cl : String = anAtomType.className();
        internalNotBasicData : Collection(DataDeclaration) = anAtomType.allDataDeclarations()->select(ddd:DataDeclaration| not ddd.dataType.native);
    }
]
0 [for (dd : DataDeclaration | internalNotBasicData) before('+ ') separator('+')][dd.dataType.functionNameForSizeOfNBD()/]([dd.varName()/])[/for]
[/template]

[template public generateImplemBody(anAtomType : AtomType, disableSerialization: Boolean)
    {
        cl : String = anAtomType.className();
    }]
[if (not disableSerialization)]
#include <iostream>
#include <sstream>
[/if]

#include <CycleInAtomPrioritiesError.hpp>
#include <NonDeterministicPetriNetError.hpp>
#include <NonOneSafePetriNetError.hpp>
#include <AtomInvariantViolationError.hpp>

[for (aState : State | anAtomType.behavior.states)]

bool [cl/]::at[aState.name/] () const {
    return __statesbv['['/] [aState.cindex() /]/(8*sizeof(int))[']'/] & 1<< ([aState.cindex()/]%(8*sizeof(int)));
}

bool [cl/]::to[aState.name/] () {
    if (at[aState.name/]()) return false;
    __statesbv['['/] [aState.cindex() /]/(8*sizeof(int))[']'/] |= 1<< ([aState.cindex()/]%(8*sizeof(int)));
    return true;
}

bool [cl/]::from[aState.name/] () {
    if (!at[aState.name/]()) return false;
    __statesbv['['/] [aState.cindex() /]/(8*sizeof(int))[']'/] &= ~(1<< ([aState.cindex()/]%(8*sizeof(int))));
    return true;
}
[/for]

[cl/]::[anAtomType.genCtorProto()/] :  ComponentItf(name, ATOM), Atom(name, [if (anAtomType.behavior.initialResume->isEmpty())]false[else]true[/if]) [anAtomType.genCtorInit()/] {
[for (decl : AtomInternalPortDeclaration | internalPorts(anAtomType)) separator('\n    // link data internal to internal port\n')]
    this->addInternalPort([decl.varName()/]);
[/for][for (decl : AtomExternalPortDeclaration | externalPorts(anAtomType)) separator('\n    // link data external to internal port\n')]
    this->addExternalPort([decl.varName()/]);
[/for]
[for (decl : AtomExportPortDeclaration | anAtomType.exportPortDeclarations) before('    // export port\n')]
    this->addPort([decl.varName()/]);
[/for]
[for (decl : AtomInternalDataDeclaration | anAtomType.exportedData()) before('    // export data\n')]
    this->addData([decl.exportedVarName()/]);
[/for]
[if (anAtomType.hasTimingConstraint())]
[for (decl : AtomInternalPortDeclaration | anAtomType.internalPorts(anAtomType)) before('    // link timing constraints to port values\n')]
    [decl.getPVVarName()/].setInterval([decl.getGuardAfterPrioVarName()/]);
    [decl.getPVVarName()/].setGuard([decl.getGuardConstraintVarName()/]);
[/for]
[for (decl : AtomExternalPortDeclaration | anAtomType.externalPorts(anAtomType)) before('    // link timing constraints to external ports\n')]
    [decl.varName()/].setInterval([decl.getGuardAfterPrioVarName()/]);
[/for]
[/if]
//Lotfi
[for (anIPD : AtomInternalPortDeclaration | anAtomType.internalPorts(anAtomType)) ]
		[if (anIPD.hasAnnotation('stochastic', 'clk'))]
			[if (anIPD.isConstAnnotation('stochastic', 'clk') = false)]
				[for (cd : ClockDeclaration |anAtomType.allClockDeclarations())]
    				[if (cd.name = anIPD.getAnnotation('stochastic', 'clk'))]
// staticallocated::[anIPD.varName()/].setDistribution("[anIPD.getAnnotation('stochastic', 'clk') /]");
[ anIPD.varName()/].setClock(&[cd.varName()/]);
					[/if]				
    			[/for]	

				[if (anAtomType.hasClockDeclaration(anIPD.getAnnotation('stochastic', 'clk')) = false)]
				 #error clock name [anIPD.getAnnotation('stochastic', 'clk')/] not declared in this scope
								
				[/if]
			[else]
				#error clock name has to be a variable name, not a const string
			[/if]
		[else]
			[if (anIPD.hasAnnotation('stochastic'))]
				#error stochastic annotation with no specified clock
			[/if]
		[/if]

	[/for]

}

vector<Constraint> [cl/]::allTimingConstraints() const {
    vector<Constraint> ret;
    
[for (timingConstraints : BinaryOpExpression | anAtomType.behavior.transitions->collect(getTimingConstraint(guard))->union(anAtomType.invariants->collect(getTimingConstraint(guard))))]
	ret.push_back([generateExpressionWithoutCastMC(timingConstraints)/]);
[/for]
    return ret;
}

BipError& [cl/]::execute(PortValue &portValue, const TimeValue &t) {
    BipError *ret = &BipError::NoError;

    bool hasResume = portValue.hasResume();

#ifndef NDEBUG
    bool something_happened = false;
#endif

[if (anAtomType.hasTimingConstraint())]
    // set new logical time
    setTime(t);

[/if]
    // find the right transitions to execute
[for (t : Transition | internalPortTransitions(anAtomType)) before('    ') separator(' else ')]
if ((&[t.triggerPort.oclAsType(AtomInternalPortDeclaration).getPVVarName()/] == &portValue) && [if (hasTimingConstraint())]![t.uniqueVarName()/].empty()[else][t.uniqueVarName()/][/if]) {
        // check consistency (enabledness, port values, ...)
        assert([t.triggerPort.oclAsType(AtomInternalPortDeclaration).varName()/].hasPortValue());
        assert(&[t.triggerPort.oclAsType(AtomInternalPortDeclaration).varName()/].portValue() == &portValue);

        // check at most one transitions is executed
        assert(!something_happened);
[if (isOptimEnabled('ports-reset'))]

        // reset ports exporting variables modified by transition execution
		[for (aep : AtomExportPortDeclaration | anAtomType.exportPortDeclarations)]
        [if (exportedVariables(aep)->intersection(writtenVariables(t))->notEmpty())]
        [aep.varName()/].setIsReset(true);
		[else]
        [aep.varName()/].setIsReset(false);
		[/if]
		[/for]
[/if]
        [for (aidd : AtomInternalDataDeclaration | anAtomType.exportedData()) before('\n        // reset exported data\n')]
[if (isOptimEnabled('ports-reset'))]
        [if (writtenVariables(t)->includes(aidd))]
        [aidd.exportedVarName()/].setIsReset(true);
        [else]
        [aidd.exportedVarName()/].setIsReset(false);
		[/if]
[else]
        [aidd.exportedVarName()/].setIsReset(true);
[/if]
		[/for]

[generateTransitionExecution(t, '        ')/]
        
#ifndef NDEBUG
        something_happened = true;
#endif
    }[/for]

    if (ret->type() != NO_ERROR) return *ret;

    // check that at least one transition has been executed
    assert(something_happened);

    // execute internal transitions
    ret = &executeInternalTransitions();

    if (ret->type() == NO_ERROR &&
        !hasResume) {
        ret = &update();
    }

    return *ret;
}

BipError& [cl/]::execute(PortValue &portValue) {
    BipError *ret = &BipError::NoError;

#ifndef NDEBUG
    bool something_happened = false;
#endif

    // find the right transitions to execute
[for (t : Transition | internalPortTransitions(anAtomType)) before('    ') separator(' else ')]
if ((&[t.triggerPort.oclAsType(AtomInternalPortDeclaration).getPVVarName()/] == &portValue) && [if (hasTimingConstraint())][t.uniqueConstraintVarName()/].hasTimingConstraints()[else][t.uniqueVarName()/][/if]) {
        // check consistency (enabledness, port values, ...)
        assert([t.triggerPort.oclAsType(AtomInternalPortDeclaration).varName()/].hasPortValue());
        assert(&[t.triggerPort.oclAsType(AtomInternalPortDeclaration).varName()/].portValue() == &portValue);
        [if (hasTimingConstraint())]assert([t.uniqueConstraintVarName()/].constrain());[/if]

        // check at most one transitions is executed
        assert(!something_happened);
[if (isOptimEnabled('ports-reset'))]

        // reset ports exporting variables modified by transition execution
		[for (aep : AtomExportPortDeclaration | anAtomType.exportPortDeclarations)]
        [if (exportedVariables(aep)->intersection(writtenVariables(t))->notEmpty())]
        [aep.varName()/].setIsReset(true);
		[else]
        [aep.varName()/].setIsReset(false);
		[/if]
		[/for]
[/if]
        [for (aidd : AtomInternalDataDeclaration | anAtomType.exportedData()) before('\n        // reset exported data\n')]
[if (isOptimEnabled('ports-reset'))]
        [if (writtenVariables(t)->includes(aidd))]
        [aidd.exportedVarName()/].setIsReset(true);
        [else]
        [aidd.exportedVarName()/].setIsReset(false);
		[/if]
[else]
        [aidd.exportedVarName()/].setIsReset(true);
[/if]
		[/for]

[generateTransitionExecutionMC(t, '        ')/]
        
#ifndef NDEBUG
        something_happened = true;
#endif
    }[/for]

    if (ret->type() != NO_ERROR) return *ret;

    // check that at least one transition has been executed
    assert(something_happened);

    return *ret;
}

BipError& [cl/]::execute(AtomExternalPort &port, const TimeValue &time) {
    BipError *ret = &BipError::NoError;

    bool hasResume = port.hasResume();

#ifndef NDEBUG
    bool something_happened = false;
#endif

[if (anAtomType.hasTimingConstraint())]
    // set new logical time
    setTime(time);

[/if]
[for (decl : AtomExternalPortDeclaration | externalPorts(anAtomType)) separator('\n')]
    if (&port == &[decl.varName()/]) {
        // make sure that '[decl.name/]' needs to be executed
        assert ([decl.varName()/].waiting() && [decl.varName()/].hasEvent());
        [for (param : DataDeclarationReferenceDataParameter | decl.dataParameters) before('\n        // synchronize external data with internal data\n') after('\n')]
        [param.dataDeclarationReference.varName()/] = [decl.varName()/].[accessorName(param.parameterDeclaration)/]();
        [/for]
        [for (t : Transition | externalPortTransitions(anAtomType)->select(t : Transition | t.triggerPort = decl))
    	    before('        // find the right transition to execute\n') separator('\n')]
        if ([if (hasTimingConstraint(t))]![t.uniqueVarName()/].empty()[else][t.uniqueVarName()/][/if]) {
            assert(!something_happened);

[generateTransitionExecution(t, '            ')/]

            // pop event
            [decl.varName()/].popEvent();

#ifndef NDEBUG
            something_happened = true;
#endif
        }
[/for]
    }
[/for]
    if (ret->type() != NO_ERROR) return *ret;

    // check that at least one transition has been executed
    assert(something_happened);

    // execute internal transitions
    ret = &executeInternalTransitions();

    if (ret->type() == NO_ERROR &&
        !hasResume) {
        ret = &update();
    }

    return *ret;
}

BipError& [cl/]::initialize() {
    BipError *ret = &BipError::NoError;
    
[for (cd : ClockDeclaration | allClockDeclarations(anAtomType)) before('    // add clocks to DBM\n    if (Clock::hasDbm()) {\n') after('    }')]
        [cd.varName()/].addToDbm();
[/for]

[for (decl : AtomInternalPortDeclaration | internalPorts(anAtomType)) before('    // reset status of ports\n')]
    [decl.varName()/].clearPortValue();
[/for]

[if (anAtomType.hasTimingConstraint())]

[for (t : Transition | transitions(anAtomType)) before('    // reset status of transitions\n    if (Clock::hasModelClock()) {\n') after('    }')]
        [t.uniqueVarName()/] = false;
[/for]
[for (t : Transition | transitions(anAtomType)) before('    // reset status of transitions\n    else if (Clock::hasDbm()) {\n') after('    }')]
	[if (hasTimingConstraint(t))][t.uniqueConstraintVarName()/][else][t.uniqueVarName()/][/if] = false;
[/for]
[/if]

    // initialize to empty marking
    for (unsigned int idx = 0; idx < bvector_size; idx++){
        __statesbv['['/]idx[']'/] = 0;
    }

[generateInitialTransitionExecution(anAtomType.behavior, '    ')/]

    if (ret->type() != NO_ERROR) return *ret;

    // execute (initial) internal transitions
    ret = &executeInternalTransitions();

    if (ret->type() == NO_ERROR &&
        !initialHasResume() && Clock::hasModelClock()) {
        ret = &update();
    }

    return *ret;
}

BipError& [cl/]::checkInvariants() {
[generateCheckInvariants(anAtomType, '    ')/]
    return BipError::NoError;
}

BipError &[cl/]::resume(const TimeValue &t) {
    // should not be already resumed 
[if (anAtomType.hasTimingConstraint())]
    assert(!hasInvariant() || [atomInvariant(anAtomType)/].in(t));
    assert(resume().in(t));

    // set new logical time
    setTime(t);
[/if]
    
    return update();
}
[if (not disableSerialization)]

string [cl/]::toString() const {
    ostringstream oss;
    bool first=true;
    [for (state : State | anAtomType.behavior.states)]
    if (at[state.name/]()) {
      if (!first) oss << ", ";
      else {
        first = false;
        oss << name() ;
      }
      oss << ".[state.name/]";
    }
    [/for]

    [for (dd : DataDeclaration | anAtomType.allDataDeclarations())]
    if (first) first = false;
    oss << ", " << name() << ".[dd.name/] = " << [dd.varName()/];
    [/for]
    if (Clock::hasModelClock()) {
        [for (cd : ClockDeclaration | anAtomType.allClockDeclarations())]
        if (first) first = false;
        else oss << std::endl;
        oss << "[cd.name/]=" << [cd.varName()/].time();
        [/for]
    

        [for (i : AtomInvariant | anAtomType.invariants)]
        if (first) first = false;
        else oss << std::endl;
        oss << "[i.name/]=";
        if ([i.testSources()/])
          oss << ([i.guard.generateExpression()/]);
        else
          oss << "true";
        [/for]
    }
    return oss.str(); 
}
[/if]

BipError& [cl/]::update() {
    BipError *ret = &BipError::NoError;

[if (isOptimEnabled('transitions-update'))]
    switch (__previous) {
       case -1:
         ret = &update_all();
         break;

       case 0:
         ret = &update_initial();
         break;
    [for (t : Transition | transitions(anAtomType)) before('\n') separator('\n')]
       case [index(t)/]:
         ret = &update_[index(t)/]();
         break; 
    [/for]

        default:
          assert(false);
    }
[else]
    [generateUpdateFromScratch(anAtomType)/]
[/if]

[if (isOptimEnabled('ports-reset'))]

    if (__previous == -1) {
        // values of variables associated to ports may have changed
        [for (decl : AtomExportPortDeclaration | anAtomType.exportPortDeclarations)]
        [decl.varName()/].setIsReset(true);
        [/for]
    }
[/if]

    return *ret;
}

[if (isOptimEnabled('transitions-update'))]
BipError& [cl/]::update_all() {
    BipError *ret = &BipError::NoError;

    [generateUpdateFromScratch(anAtomType)/]

    return *ret;
}

BipError& [cl/]::update_initial() {
    BipError *ret = &BipError::NoError;

    [generateUpdateFromInitial(anAtomType)/]

    return *ret;
}


[for (previous : Transition | transitions(anAtomType))]
BipError& [cl/]::update_[index(previous)/]() {
    BipError *ret = &BipError::NoError;

    [generateUpdate(anAtomType, previous)/]

    return *ret;
}

[/for]
[/if]

BipError &[cl/]::executeInternalTransitions() {
    BipError &ret = BipError::NoError;

    // used to record the enabled internal transition
    int __enabled_internal = 0;

    do {
[if (isOptimEnabled('transitions-update'))]
        // recompute the enabled internal transition(s)
        switch (__previous) {
          case -1:
            [for (t : Transition | internalTransitions(anAtomType))]
            if ([t.testSources()/]
[if (t.guard->notEmpty())][t.gtc()/][/if]
                [t.testGuard('&&')/]) {
                [t.uniqueVarName()/] = true;

                if (__enabled_internal == 0) {
                    __enabled_internal = [index(t)/];
                }
                else {
                    NonDeterministicPetriNetError *r = new NonDeterministicPetriNetError(*this);
                    return *r;
                }
            }
            else {
                [t.uniqueVarName()/] = false;
            }

            [/for]
            break;

          case 0:
            [for (t : Transition | internalTransitions(anAtomType)->select(enabledDependsOnInitial()))]
            if ([t.testSources()/]
[if (t.guard->notEmpty())][t.gtc()/][/if]
                [t.testGuard('&&')/]) {
                [t.uniqueVarName()/] = true;

                if (__enabled_internal == 0) {
                    __enabled_internal = [index(t)/];
                }
                else {
                    NonDeterministicPetriNetError *r = new NonDeterministicPetriNetError(*this);
                    return *r;
                }
            }
            else {
                [t.uniqueVarName()/] = false;
            }

            [/for]
            break;
          [for (previous : Transition | transitions(anAtomType)) before('\n') separator('\n')]
          case [index(previous)/]:
            [if (previous.triggerPort->isEmpty())]
            assert(__previous == __enabled_internal);

            [/if]
            [if (previous.enabledDependsOn(previous))]
            // reset enabled internal transition
            __enabled_internal = 0;

            [/if]
            [for (t : Transition | anAtomType.behavior.transitions->select(triggerPort->isEmpty() and enabledDependsOn(previous)))]
            if ([t.testSources()/]
[if (t.guard->notEmpty())][t.gtc()/][/if]
                [t.testGuard('&&')/]) {
                [t.uniqueVarName()/] = true;

                if (__enabled_internal == 0) {
                   __enabled_internal = [index(t)/];
                }
                else {
                    NonDeterministicPetriNetError *r = new NonDeterministicPetriNetError(*this);
                    return *r;
                }
            }
            else {
                [t.uniqueVarName()/] = false;
            }

            [/for]
            break;
        [/for]

        default:
          assert(false);
        }
[else]
        // recompute enabled internal transitions
        __enabled_internal = 0;

        [for (t : Transition | internalTransitions(anAtomType))]
        if ([t.testSources()/]
[if (t.guard->notEmpty())][t.gtc()/][/if]
            [t.testGuard('&&')/]) {
            [t.uniqueVarName()/] = true;

            if (__enabled_internal == 0) {
                __enabled_internal = [index(t)/];
            }
            else {
                NonDeterministicPetriNetError *r = new NonDeterministicPetriNetError(*this);
                return *r;
            }
        }
        else {
            [t.uniqueVarName()/] = false;
        }
        [/for]
[/if]

        // execute the enabled internal transition if exist
        if (__enabled_internal != 0) {
            switch (__enabled_internal) {
              [for (t : Transition | internalTransitions(anAtomType))]
              case [index(t)/]:
                // enabled internal transition should be enabled
                assert([t.uniqueVarName()/]);

                // execute internal transition
[generateTransitionExecution(t, '                ')/]

                [if (isOptimEnabled('ports-reset'))]
                // reset exported ports if exported data are modified
                [for (p : AtomExportPortDeclaration | anAtomType.exportPortDeclarations->select(p : AtomExportPortDeclaration | exportedVariables(p)->intersection(writtenVariables(t))->notEmpty()))]
                [p.varName()/].setIsReset(true);
                [/for]
                [/if]
                break;

              [/for]

              default:
                assert(false);
            }
        }
    } while (__enabled_internal != 0);

    return ret;
}

[cl /]::~[cl /]() {
}
[/template]

[template private generateRecomputePort(port : AtomExportPortDeclaration) ? (isOptimEnabled('ports-reset')) post(trim())]
// check whether status of [port.name/] has changed
if ([for (iport : AtomInternalPortDeclaration | port.portDeclarationReferences) separator(' && ')][iport.varName()/].hasPortValue() == false && [iport.varName()/].isPreviouslyEnabled() == false[/for]) {
    [port.varName()/].setIsReset(false);
}
else if ([for (iport : AtomInternalPortDeclaration | port.portDeclarationReferences) separator(' || ')][iport.varName()/].hasPortValue() != [iport.varName()/].isPreviouslyEnabled()[/for]) {
    // force recomputation of connectors involving [port.name/]
    [port.varName()/].setIsReset(true);

    [generateRecomputePortValues(port)/]
}
[if (port.eContainer(AtomType).hasTimingConstraint())]
else if ([for (iport : AtomInternalPortDeclaration | port.portDeclarationReferences) separator(' || ')][iport.getGuardAfterPrioVarName()/] != [iport.varName()/].previousInterval() || [iport.getPVVarName()/].urgency() != [iport.varName()/].previousUrgency()[/for]) {
    // reset the exported port [port.name/] if the status of internal ports has changed
    [port.varName()/].setIsReset(true);
}
[/if]
[/template]

[template private generateRecomputePort(port : AtomExportPortDeclaration) ? (not isOptimEnabled('ports-reset')) post(trim())]
// force recomputation of connectors involving [port.name/]
[port.varName()/].setIsReset(true);

[generateRecomputePortValues(port)/]
[/template]

[template private generateRecomputePortValues(port : AtomExportPortDeclaration) post(trim())]
// recompute port values of [port.name/] from scratch
this->[port.varName()/].portValues().clear();

[for (iport : AtomInternalPortDeclaration | port.portDeclarationReferences) separator('\n')]
// check port value of [iport.name/] exported by [port.name/]
if (this->[iport.varName()/].hasPortValue()) {
    this->[port.varName()/].addPortValue([iport.getPVVarName()/]);
}
[/for]
[/template]

[template private generateRecomputePortValue(port : AtomInternalPortDeclaration) post(trim())]
[if (isOptimEnabled('ports-reset'))]
// keep track of the previous status of [port.name/]
this->[port.varName()/].setIsPreviouslyEnabled(this->[port.varName()/].hasPortValue());

[/if]
[if (hasTimingConstraint(port.eContainer(AtomType)))]
if (this->[port.varName()/].isEnabled() && ![port.getGuardAfterPrioVarName()/].empty()) {
    this->[port.varName()/].setPortValue([port.getPVVarName()/]);
}
else {
    this->[port.varName()/].clearPortValue();
}
[else]
// update port value of [port.name/]
if (this->[port.varName()/].isEnabled() && !this->[port.varName()/].isDisabledByPriorities()) {
    this->[port.varName()/].setPortValue([port.getPVVarName()/]);
}
else {
    this->[port.varName()/].clearPortValue();
}
[/if]
[/template]


[template private generateResetPort(port : AtomInternalExternalPortDeclaration, stableTransitions : Set(Transition)) post(trim()) ]
INCOMPLETE, MISSING TEMPLATE FOR A SUBTYPE OF 'AtomInternalExternalPortDeclaration'
[/template]

[template private generateResetPort(port : AtomInternalPortDeclaration, stableTransitions : Set(Transition)) post(trim())]
[if (stableTransitions->isEmpty())]
this->[port.varName()/].setIsEnabled(false);
[else]
this->[port.varName()/].setIsEnabled([for (t : Transition | stableTransitions) separator(' || ')][if (hasTimingConstraint(t))]![t.uniqueVarName()/].empty()[else][t.uniqueVarName()/][/if][/for]);
[/if]
[/template]

[template private generateResetPort(port : AtomExternalPortDeclaration, stableTransitions : Set(Transition)) post(trim())]
[if (stableTransitions->isEmpty())]
this->[port.varName()/].setWaiting(false);
[else]>intersection(writtenVariables(transition
this->[port.varName()/].setWaiting([for (t : Transition | stableTransitions) separator(' || ')][if (hasTimingConstraint(t))]![t.uniqueVarName()/].empty()[else][t.uniqueVarName()/][/if][/for]);
[/if]
[/template]

[template private generateActivatePort(transition : Transition, port : AtomInternalExternalPortDeclaration) post(trim())]
#error INCOMPLETE, MISSING TEMPLATE FOR A SUBTYPE OF 'AtomInternalExternalPortDeclaration' for [port.name/]
[/template]

[template private generateActivatePort(transition : Transition, port : AtomInternalPortDeclaration) post(trim())]
if ([port.varName()/].isEnabled()) {
    NonDeterministicPetriNetError *r = new NonDeterministicPetriNetError(*this);
    r->setPort([port.varName()/]);

    return *r;
}

[port.varName()/].setIsEnabled(true);
[port.getPVVarName()/].setHasResume([if (transition.resume->isEmpty())]false[else]true[/if]);
[if (hasTimingConstraint(port.eContainer(AtomType)))]
if (Clock::hasModelClock()) {
    [port.getGuardVarName()/] = [transition.uniqueVarName()/];
    [port.getGuardAfterPrioVarName()/] = [port.getGuardVarName()/];
} else if (Clock::hasDbm()) {
    [port.getGuardConstraintVarName()/] = [if (transition.hasTimingConstraint())][transition.uniqueConstraintVarName()/][else][transition.uniqueVarName()/][/if];
}
[port.getPVVarName()/].setUrgency([genUrgency(transition.urgency)/]);
[/if]
[/template]

[template private generateActivatePort(transition : Transition, port : AtomExternalPortDeclaration) post(trim())]
if ([port.varName()/].waiting()) {
    NonDeterministicPetriNetError *r = new NonDeterministicPetriNetError(*this);
    // FIXME: not the right type! r->setPort([port.varName()/]);
    // it is the caller's responsibility to handle memory.
    // there need to be a 'delete' somewhere. 
    return *r;
}

[port.varName()/].setWaiting(true);
[port.varName()/].setHasResume([if (transition.resume->isEmpty())]false[else]true[/if]);
[if (hasTimingConstraint(port.eContainer(AtomType)))]
[port.getGuardVarName()/] = [transition.uniqueVarName()/];
[port.getGuardAfterPrioVarName()/] = [port.getGuardVarName()/];
[port.varName()/].setUrgency([genUrgency(transition.urgency)/]);
[/if]
[/template]

[template private generateUpdatePort(port : AtomInternalExternalPortDeclaration,
	transitions : Set(Transition),
	enabledTransitions : Set(Transition),
	disabledTransitions : Set(Transition)) post(trim()) {
	stableTransitions : Set(Transition) = transitions(port) - transitions;
}]
// reset status of port [port.name/]
[generateResetPort(port, stableTransitions)/]

[for (t : Transition | enabledTransitions)]
[if (t.guard->isEmpty())]
[if (hasTimingConstraint(t))]
if (Clock::hasModelClock()) {
    [t.uniqueVarName()/] = true;
} else if (Clock::hasDbm()) {
    [t.uniqueConstraintVarName()/] = true;
}
[else]
[t.uniqueVarName()/] = true;
[/if]

[generateActivatePort(t, t.triggerPort)/]
[else]
[t.uniqueVarName()/] = [t.guard.generateExpression()/];

[if (hasTimingConstraint(t))]
if ((Clock::hasModelClock() && ![t.uniqueVarName()/].empty()) || (Clock::hasDbm() && [t.uniqueConstraintVarName()/].isSatisfied())) {
[else]
if ([t.uniqueVarName()/]) {
[/if]
    [generateActivatePort(t, t.triggerPort)/]
}
[/if]
[/for]
[for (t : Transition | disabledTransitions)]
[if (hasTimingConstraint(t))]
if (Clock::hasModelClock()) {
    [t.uniqueVarName()/] = false;
} else if (Clock::hasDbm()) {
    [t.uniqueConstraintVarName()/] = false;
}
[else]
[t.uniqueVarName()/] = false;
[/if]
[/for]
[for (t : Transition | (transitions - enabledTransitions) - disabledTransitions)]
if (Clock::hasModelClock()) {
    [t.uniqueVarName()/] = ([t.testSources()/]
[if (t.guard->notEmpty())][t.gtc()/][/if]
            [t.testGuard('&&')/]);
} else if (Clock::hasDbm()) {
    [if (hasTimingConstraint(t))][t.uniqueConstraintVarName()/][else][t.uniqueVarName()/][/if] = ([t.testSources()/]
[if (t.guard->notEmpty())][t.gtc()/][/if]
            [t.testGuardMC('&&')/]);
}

[if (hasTimingConstraint(t))]
if ((Clock::hasModelClock() && ![t.uniqueVarName()/].empty()) || (Clock::hasDbm() && [t.uniqueConstraintVarName()/].isSatisfied())) {
[else]
if ([t.uniqueVarName()/]) {
[/if]
    [generateActivatePort(t, t.triggerPort)/]
}
[/for]
[/template]

[template private generateUpdateFromScratch(atom : AtomType) post(trim())]
[generateUpdate(atom, atom.behavior.transitions, OrderedSet { }, OrderedSet { }, atom.priorities)/]
[/template]

[template private generateUpdateFromInitial(atom : AtomType) post(trim()) {
	transitions : OrderedSet(Transition) =
		portTransitions(atom)
			->select(t : Transition |
				t.enabledDependsOnInitial() and
				not (isOptimEnabled('early-update') and t.canBeEarlyUpdatedByInitial()));

	enabledTransitions : OrderedSet(Transition) =
		transitions
			->select(t : Transition |
					t.isEnabledByInitial());

	priorities : OrderedSet(AtomPriorityDeclaration) =
		atom.priorities
			->select(prio : AtomPriorityDeclaration |
					prio.enabledDependsOnInitial() and
					not (isOptimEnabled('early-update') and not prio.enabledCannotBeEarlyUpdatedByInitial()));
}]
[generateUpdate(atom, transitions, enabledTransitions, OrderedSet { }, atom.priorities)/]
[/template]

[template private generateUpdate(atom : AtomType, transition : Transition) ? (transition.triggerPort->isEmpty()) post(trim()) {
	transitions : OrderedSet(Transition) =
		portTransitions(atom)
			->select(t : Transition |
				t.enabledDependsOnBackwardPaths(transition));

	enabledTransitions : OrderedSet(Transition) =
		transitions
			->select(t : Transition |
				t.isEnabledByBackwardPaths(transition));

	disabledTransitions : OrderedSet(Transition) =
		transitions
			->select(t : Transition |
				t.isDisabledByBackwardPaths(transition));

	priorities : OrderedSet(AtomPriorityDeclaration) =
		atom.priorities
			->select(prio : AtomPriorityDeclaration |
					prio.enabledDependsOnBackwardPathsToPortTransitionsOf(transition));
}]
[generateUpdate(atom, transitions, enabledTransitions, disabledTransitions, priorities)/]
[/template]

[template private generateUpdate(atom : AtomType, transition : Transition) ? (transition.triggerPort->notEmpty()) post(trim()) {
	transitions : OrderedSet(Transition) =
		portTransitions(atom)
			->select(t : Transition |
				t.enabledDependsOn(transition) and
				not (isOptimEnabled('early-update') and t.canBeEarlyUpdatedBy(transition)));

	enabledTransitions : OrderedSet(Transition) =
		transitions
			->select(t : Transition |
				t.isEnabledBy(transition));

	disabledTransitions : OrderedSet(Transition) =
		transitions
			->select(t : Transition |
				t.isDisabledBy(transition));

	priorities : OrderedSet(AtomPriorityDeclaration) =
		atom.priorities
			->select(prio : AtomPriorityDeclaration |
				prio.enabledDependsOn(transition) and
				not (isOptimEnabled('early-update') and not prio.enabledCannotBeEarlyUpdatedBy(transition)));
}]
[generateUpdate(atom, transitions, enabledTransitions, disabledTransitions, priorities)/]
[/template]

[template private generateEarlyUpdateFromInitial(atom : AtomType) post(trim()) {
	transitions : OrderedSet(Transition) =
		portTransitions(atom)
			->select(t : Transition |
				t.enabledDependsOnInitial() and
				t.canBeEarlyUpdatedByInitial());

	enabledTransitions : OrderedSet(Transition) =
		transitions
			->select(t : Transition |
					t.isEnabledByInitial());

	ports : OrderedSet(AtomExportPortDeclaration) =
		atom.exportPortDeclarations
			->select(p : AtomExportPortDeclaration |
				p.canBeEarlyUpdatedByInitial());

	variables : OrderedSet(AtomInternalDataDeclaration) =
		exportedData(atom)
			->select(dd : AtomInternalDataDeclaration |
				dd.valueCanBeEarlyUpdatedByInitial());

	priorities : OrderedSet(AtomPriorityDeclaration) =
		atom.priorities
			->select(prio : AtomPriorityDeclaration |
				prio.enabledDependsOnInitial() and
				not prio.enabledCannotBeEarlyUpdatedByInitial());
}]
[generateUpdate(atom, transitions, enabledTransitions, OrderedSet { }, priorities)/]
[generatePortsReady(ports)/]
[generateVariablesReady(variables)/]
[/template]

[template private generateEarlyUpdate(atom : AtomType, transition : Transition) post(trim()) {
	transitions : OrderedSet(Transition) =
		portTransitions(atom)
			->select(t : Transition |
				t.enabledDependsOn(transition) and
				t.canBeEarlyUpdatedBy(transition));

	enabledTransitions : OrderedSet(Transition) =
		transitions
			->select(t : Transition |
				t.isEnabledBy(transition));

	disabledTransitions : OrderedSet(Transition) =
		transitions
			->select(t : Transition |
				t.isDisabledBy(transition));

	ports : OrderedSet(AtomExportPortDeclaration) =
		atom.exportPortDeclarations
			->select(p : AtomExportPortDeclaration |
				p.canBeEarlyUpdatedBy(transition));

	variables : OrderedSet(AtomInternalDataDeclaration) =
		exportedData(atom)
			->select(dd : AtomInternalDataDeclaration |
				dd.valueCanBeEarlyUpdatedBy(transition));

	priorities : OrderedSet(AtomPriorityDeclaration) =
		atom.priorities
			->select(prio : AtomPriorityDeclaration |
				prio.enabledDependsOn(transition) and
				not prio.enabledCannotBeEarlyUpdatedBy(transition));
}]
[generateUpdate(atom, transitions, enabledTransitions, disabledTransitions, priorities)/]
[generatePortsReady(ports)/]
[generateVariablesReady(variables)/]
[/template]

[template private generatePortReady(port : AtomExportPortDeclaration) post(trim())]
[port.varName()/].setReady();
[/template]

[template private generatePortsReady(ports : OrderedSet(AtomExportPortDeclaration)) post(trim())]
[for (port : AtomExportPortDeclaration | ports)]
[generatePortReady(port)/]
[/for]
[/template]

[template private generateVariableReady(variable : AtomInternalDataDeclaration) post(trim())]
[variable.exportedVarName()/].setReady();
[/template]

[template private generateVariablesReady(variables : OrderedSet(AtomInternalDataDeclaration)) post(trim())]
[for (var : AtomInternalDataDeclaration | variables)]
[generateVariableReady(var)/]
[/for]
[/template]

[template private generateUpdate(atom : AtomType,
	transitions : OrderedSet(Transition),
	enabledTransitions : OrderedSet(Transition),
	disabledTransitions : OrderedSet(Transition),
	priorities : OrderedSet(AtomPriorityDeclaration)) post(trim())]
[for (p : AtomInternalExternalPortDeclaration |
		atom.internalPortDeclarations->union(atom.externalPortDeclarations)
			->select(p : AtomInternalExternalPortDeclaration | p.enabledDependsOn(transitions)))
	before('\n// update status of internal/external ports w.r.t. transitions\n')
	separator('\n')]
[generateUpdatePort(p,
	transitions->intersection(transitions(p)),
	enabledTransitions->intersection(transitions(p)),
	disabledTransitions->intersection(transitions(p)))/]
[/for]
[generatePriorities(transitions, priorities, 'ret')/]
[for (port : AtomInternalPortDeclaration |
		atom.internalPortDeclarations
			->select(p : AtomInternalPortDeclaration | p.enabledDependsOn(transitions) or p.disabledByPrioritiesDependsOn(transitions, priorities)))
	before('\n')
	separator('\n')]
[generateRecomputePortValue(port)/]
[/for]
[for (port : AtomExportPortDeclaration |
		atom.exportPortDeclarations
			->select(p : AtomExportPortDeclaration | p.enabledDependsOn(transitions, priorities)))
	before('\n')
	separator('\n')]
[if (isOptimEnabled('early-update'))]
if (![port.varName()/].isReady()) {
  [generateRecomputePort(port)/]
}
[else]
[generateRecomputePort(port)/]
[/if]
[/for]
[/template]

[template private generateInitialTransitionExecution(pn : PetriNet, tab : String) {
	atom : AtomType = pn.eContainer(AtomType);
}]
[tab/]// marking must be initialized to empty
[tab/]assert([for (s : State | pn.states) separator(' && ')](!at[s.name/]())[/for]);
[for (ts : State | pn.initStates) before('\n' + tab + '// update initial places\n')]
[tab/]to[ts.name/]();
[/for]

[tab/]// record the index of the latest executed transition
[tab/]__previous = 0;
[if (isOptimEnabled('early-update'))]

[tab/]// early update of ports and variables
[tab/][generateEarlyUpdateFromInitial(pn.eContainer(AtomType))/]
[/if]
[for (exp : Expression | pn.initialActions)
	before('\n' + tab + '// execute transition actions\n')
	after('\n' + tab + '// end of execute transition actions\n')]
[exp.gtc()/]
[tab/][exp.generateExpression()/];
[/for]

[if (pn.initialResume->notEmpty())]
[if (pn.initialResume.guard->notEmpty())]
[tab/][atomResume(atom)/] = ([pn.initialResume.guard.generateExpression()/]);
[else]
[tab/][atomResume(atom)/] = Interval(TimeValue::MIN, TimeValue::MAX);
[/if]
[/if]
[tab/]ret = &checkInvariants();
[/template]

[template private generateTransitionExecution(t : Transition, tab : String) {
	atom : AtomType = t.eContainer(PetriNet).eContainer(AtomType);
}]
[tab/]// the transition should be enabled by places
[tab/]assert([t.testSources()/]);
[for (ts : State | t.sources) before('\n' + tab + '// update input places\n')]
[tab/]from[ts.name/]();
[/for]

[tab/]// check one-safetyness
[tab/]if ([for (s : State | t.destinations) separator(' || ')]at[s.name/]()[/for]) {
[tab/]    NonOneSafePetriNetError *r = new NonOneSafePetriNetError(*this);
[tab/]    [if (t.triggerPort->notEmpty())][if (t.triggerPort.oclIsKindOf(AtomInternalPortDeclaration))]r->setPort([t.triggerPort.varName() /]);[/if][/if]
[tab/]    return *r;
[tab/]}
[for (ts : State | t.destinations) before('\n' + tab + '// update output places\n')]
[tab/]to[ts.name/]();
[/for]

[tab/]// record the index of the latest executed transition
[tab/]__previous = [t.eContainer(PetriNet).transitions->indexOf(t)/];
[if (isOptimEnabled('early-update') and t.triggerPort->notEmpty())]

[tab/]// early update of ports and variables
[tab/][generateEarlyUpdate(t.eContainer(PetriNet).eContainer(AtomType), t)/]
[/if]
[for (exp : Expression | t.actions)
	before('\n' + tab + '// execute transition actions\n')
	after('\n' + tab + '// end of execute transition actions\n')]
[exp.gtc()/]
[tab/][exp.generateExpression()/];
[/for]
[t.gtc()/]

[if (t.resume->notEmpty())]
[if (t.resume.guard->notEmpty())]
[tab/][atomResume(atom)/] = ([t.resume.guard.generateExpression()/]);
[else]
[tab/][atomResume(atom)/] = Interval(TimeValue::MIN, TimeValue::MAX);
[/if]
[/if]
[tab/]ret = &checkInvariants();
[/template]

[template private generateTransitionExecutionMC(t : Transition, tab : String) {
	atom : AtomType = t.eContainer(PetriNet).eContainer(AtomType);
}]
[tab/]// the transition should be enabled by places
[tab/]assert([t.testSources()/]);
[for (ts : State | t.sources) before('\n' + tab + '// update input places\n')]
[tab/]from[ts.name/]();
[/for]

[tab/]// check one-safetyness
[tab/]if ([for (s : State | t.destinations) separator(' || ')]at[s.name/]()[/for]) {
[tab/]    NonOneSafePetriNetError *r = new NonOneSafePetriNetError(*this);
[tab/]    [if (t.triggerPort->notEmpty())][if (t.triggerPort.oclIsKindOf(AtomInternalPortDeclaration))]r->setPort([t.triggerPort.varName() /]);[/if][/if]
[tab/]    return *r;
[tab/]}
[for (ts : State | t.destinations) before('\n' + tab + '// update output places\n')]
[tab/]to[ts.name/]();
[/for]

[tab/]// record the index of the latest executed transition
[tab/]__previous = [t.eContainer(PetriNet).transitions->indexOf(t)/];
[if (isOptimEnabled('early-update') and t.triggerPort->notEmpty())]

[tab/]// early update of ports and variables
[tab/][generateEarlyUpdate(t.eContainer(PetriNet).eContainer(AtomType), t)/]
[/if]
[for (exp : Expression | t.actions)
	before('\n' + tab + '// execute transition actions\n')
	after('\n' + tab + '// end of execute transition actions\n')]
[exp.gtc()/]
[tab/][exp.generateExpression()/];
[/for]
[t.gtc()/]

[tab/]ret = &checkInvariants();
[/template]

[template private generateCheckInvariants(anAtomType : AtomType, tab : String)]
[if (anAtomType.invariants->exists(i : AtomInvariant | hasTimingConstraint(i)))]
[tab/]// reset global atom invariant to true
[tab/]if (Clock::hasModelClock()) {
[tab/]    [atomInvariant(anAtomType)/] = Interval(TimeValue::MIN, TimeValue::MAX);
[tab/]} else if (Clock::hasDbm()) {
[tab/]    [atomInvariantConstraint(anAtomType)/] = true;
[tab/]}
[/if]
[for (invariant : AtomInvariant | anAtomType.invariants) before('\n') separator('\n') after('\n')]
[tab/]// check invariant '[invariant.name/]'
[if (invariant.guard->notEmpty())]
[if (hasTimingConstraint(invariant))]
[tab/]if ([invariant.testSources()/]) {
[tab/]    if (Clock::hasModelClock()) {
[tab/]        [atomInvariant(anAtomType)/] &= ([invariant.guard.generateExpression()/]);
[tab/]    } else if (Clock::hasDbm()) {
[tab/]        [atomInvariantConstraint(anAtomType)/] &= ([invariant.guard.generateExpressionMC()/]);
[tab/]    }
[tab/]
[tab/]    if ((Clock::hasModelClock() && ![atomInvariant(anAtomType)/].in(this->[currentTime(anAtomType)/])) || (Clock::hasDbm() && ![atomInvariantConstraint(anAtomType)/].constrain())) {
[tab/]        AtomInvariantViolationError *r = new AtomInvariantViolationError("[invariant.name/]", *this);
[tab/]
[tab/]        return *r;
[tab/]    }
[tab/]}
[else]
[tab/]if ([invariant.testSources()/] && !([invariant.guard.generateExpression()/])) {
[tab/]    AtomInvariantViolationError *r = new AtomInvariantViolationError("[invariant.name/]", *this);
[tab/]
[tab/]    return *r;
[tab/]}
[/if]
[/if]
[/for]
[/template]

[template public generateCMakeBody(anAtomType : AtomType) post(trim())]
[for (extra_src : String | anAtomType.getUserExtraSrc())
      before('# @cpp(src="") annotation\n')]
list(APPEND EXTRA_SRC [extra_src/])
[/for]
[/template]

[comment 
*************************************
         PRIVATE PART BELOW
*************************************
 /]

[comment 
    Builds a set of HPP file names to include for atom internal ports types.
/]
[query private aIPTypesWithRelPath(anAtomType : AtomType) : Set(String) =
    internalPorts(anAtomType)->collect(e:AtomInternalPortDeclaration | relHppFilePath(e.portType, e.portType.atomInternalClassName()))->asSet()
/]

[comment 
    Builds a set of HPP file names to include for atom external ports types.
/]
[query private aExternalPTypesWithRelPath(anAtomType : AtomType) : Set(String) =
    externalPorts(anAtomType)
		->select(e:AtomExternalPortDeclaration | e.backendName->isEmpty())
		->collect(e:AtomExternalPortDeclaration | relHppFilePath(e.portType, e.portType.atomExternalClassName()))->asSet()
/]

[comment 
    Builds a set of HPP file names to include for port values
/]
[query private pVTypesWithRelPath(anAtomType : AtomType) : Set(String) =
    internalPorts(anAtomType)->collect(e:AtomInternalPortDeclaration | relHppFilePath(e.portType, e.portType.portValueClassName()))->asSet()
/][comment 
    Builds a set of HPP file names to include for exported ports
/]

[query private aEPTypesWithRelPath(anAtomType : AtomType) : Set(String) =
    anAtomType.exportPortDeclarations->collect(e:AtomExportPortDeclaration | relHppFilePath(e.portType, e.portType.atomExportClassName()))->asSet()
/]

[comment
    Checks if there exist an exported port with the name 'anInternalName'.
    It is used to check for name collision in case the following syntax is used:
    export port PT_t a_port()
    this implicitly declares an internal port with the same name ('a_port').
    This case must be clearly identified to avoid name duplication in the CPP code.
/]
[query private findExportFromName(anAtomType : AtomType, anInternalName: String) : Boolean =
    anAtomType.exportPortDeclarations->select(e:AtomExportPortDeclaration| 
                   e.portDeclarationReferences->select(i:AtomInternalPortDeclaration| 
                             i.name.equalsIgnoreCase(anInternalName))->notEmpty() and e.name.equalsIgnoreCase(anInternalName))->notEmpty()
/]





[comment
    Returns the variable name for the exported port declaration.
/]


[query public numStates(anAtomType : AtomType) : Integer = anAtomType.behavior.states->size() /]

[template private testSources(aTransition : Transition) ? (aTransition.sources->notEmpty()) post(trim())]
[for (s : State | aTransition.sources) before('    ') separator(' && ')]at[s.name/]()[/for]
[/template]

[template private testSources(aTransition : Transition) ? (aTransition.sources->isEmpty()) post(trim())]
true
[/template]

[template private testSources(anInvariant : AtomInvariant) ? (anInvariant.exactState) post(trim())]
[for (s : State | anInvariant.eContainer(AtomType).behavior.states) before('    ') separator(' && ')][if (not anInvariant.sources->includes(s))]![/if]at[s.name/]()[/for]
[/template]

[template private testSources(anInvariant : AtomInvariant) ? (not anInvariant.exactState and anInvariant.sources->notEmpty()) post(trim())]
[for (s : State | anInvariant.sources) before('    ') separator(' && ')]at[s.name/]()[/for]
[/template]

[template private testSources(anInvariant : AtomInvariant) ? (not anInvariant.exactState and anInvariant.sources->isEmpty()) post(trim())]
true
[/template]

[template private testGuard(aTransition : Transition) post(trim())]
[if (aTransition.guard->notEmpty())]([aTransition.guard.generateExpression()/])[/if]
[/template]

[template private testGuard(aTransition : Transition, aPrefix : String) post(trim())]
[if (aTransition.guard->notEmpty())] [aPrefix/] ([aTransition.guard.generateExpression()/])[/if]
[/template]

[template private testGuardMC(aTransition : Transition, aPrefix : String) post(trim())]
[if (aTransition.guard->notEmpty())] [aPrefix/] ([aTransition.guard.generateExpressionMC()/])[/if]
[/template]

[template private genUrgency(u : Urgency) ? (u <> null)]
[if (u = Urgency::lazy)]LAZY[elseif (u = Urgency::delayable)]
DELAYABLE[elseif (u = Urgency::eager)]
EAGER[else]
// internal error[/if]
[/template]

[template private genUrgency(u : Urgency) ? (u = null)]
LAZY
[/template]

[query public cindex(aState : State) : Integer = 
    aState.eContainer(PetriNet).states->indexOf(aState)-1
/]

[comment 
    Following templates creates ',' separated list of declarations. Useful for
    init list in ctor.
/]
[template private genListIPortDecl(anAtomType : AtomType) post(trim())]
[for (decl : AtomInternalPortDeclaration | internalPorts(anAtomType)) before(', ') separator (', ')]
[decl.portType.atomInternalClassName() /] &[decl.varName()/][/for]
[/template]

[template private genListExternalPortDecl(anAtomType : AtomType) post(trim())]
[for (decl : AtomExternalPortDeclaration | externalPorts(anAtomType)) before(', ') separator (', ')]
[decl.atomExternalClassName() /] &[decl.varName()/][/for]
[/template]

[template private genListEPortDecl(anAtomType : AtomType) post(trim())]
[for (decl : AtomExportPortDeclaration | anAtomType.exportPortDeclarations) before(', ') separator (', ')]
[decl.portType.atomExportClassName() /] &[decl.varName()/][/for]
[/template]

[template private genListEDataDecl(anAtomType : AtomType) post(trim())]
[for (dd : DataDeclaration | anAtomType.exportedDataDeclarations) before(', ') separator(', ')]
[dd.dataType.exportDataClassName(anAtomType)/] &[dd.exportedVarName()/][/for]
[/template]

[template private genListDataParamDecl(anAtomType : AtomType) post(trim())]
[for (cdpd : ComponentDataParameterDeclaration | anAtomType.dataParameterDeclarations) before(', ') separator(', ')]
[cdpd.dataType.typeName()/] [cdpd.varName()/][/for]
[/template]

[comment 
    Creates the prototype of the ctor.
/]
[template private genCtorProto(anAtomType : AtomType) post(trim())]
[anAtomType.className()/](const string &name [anAtomType.genListIPortDecl()/]
                         [anAtomType.genListExternalPortDecl()/]
                         [anAtomType.genListEPortDecl()/]
                         [anAtomType.genListEDataDecl()/]
                         [anAtomType.genListDataParamDecl()/])
[/template]

[comment 
    Creates the init list of the ctor.
/]
[template private genCtorInit(anAtomType : AtomType) post(trim())]
[for (pdecl : AtomInternalPortDeclaration | internalPorts(anAtomType)) before(', ')separator(', ')]
[pdecl.varName()/]([pdecl.varName()/]), [pdecl.getPVVarName()/]([genPortValueInitialization(pdecl)/])[/for][for (pdecl : AtomExternalPortDeclaration | externalPorts(anAtomType)) before(', ')separator(', ')]
[pdecl.varName()/]([pdecl.varName()/])[/for][for (pdecl : AtomExportPortDeclaration | anAtomType.exportPortDeclarations) before (', ') separator(', ')]
[pdecl.varName()/]([pdecl.varName()/])[/for][for (ddecl : DataDeclaration | anAtomType.exportedDataDeclarations) before (', ') separator(', ')]
[ddecl.exportedVarName()/]([ddecl.exportedVarName()/])[/for][for (cdpd : ComponentDataParameterDeclaration | anAtomType.dataParameterDeclarations) before(', ') separator(', ')]
[cdpd.varName()/]([cdpd.varName()/])[/for][for (dd : AtomInternalDataDeclaration | anAtomType.internalDataDeclarations->select(d : AtomInternalDataDeclaration | not d.value->isEmpty())) before(', ') separator(', ')]
[dd.varName()/]([dd.value.generateExpression()/])[/for][for (cd : ClockDeclaration | allClockDeclarations(anAtomType)) before(', ') separator(', ')]
[cd.varName()/](*this,"[cd.name/]")[/for][for (t : Transition | transitions(anAtomType)) before(', ') separator(', ')]
[t.uniqueVarName()/](false)[/for][for (p : AtomPriorityDeclaration | anAtomType.priorities) before(', ') separator(', ')]
[p.pguardVarName()/](false)[/for][for (p : AtomPriorityDeclaration | anAtomType.priorities) before(', ') separator(', ')]
[p.penabledVarName()/](false)[/for], __previous(-1)
[/template]

[template private genPortValueInitialization(aPort : AtomInternalPortDeclaration)]
[for (aParam : DataDeclarationReferenceDataParameter | aPort.dataParameters) separator(', ')][aParam.dataDeclarationReference.oclAsType(AtomInternalDataDeclaration).varName()/][/for]
[/template]

[template public generateSubClasses(anAtomType : AtomType, aCMakeList : String, disableSerialization: Boolean) post(trim())]
[for (aType : DataType | anAtomType.exportedDataTypes())]
[anAtomType.generateExportData(aType, aCMakeList)/]
[/for]
[/template]
